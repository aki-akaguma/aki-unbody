# High-Level Design: aki-unbody

## 1. Introduction

This document describes the internal design and architecture of the `aki-unbody` command-line utility. The design is derived from the existing source code in the `src` directory and is mapped to the acceptance criteria defined in `specs/1.acceptance-criteria.md`.

## 2. High-Level Architecture

The application follows a standard Rust command-line program structure, with a clear separation between the binary entry point (`main.rs`) and the core library logic (`lib.rs`). This makes the core functionality testable and reusable.

The architecture is composed of three primary modules:

- **`conf`**: Handles command-line argument definition, parsing, and validation.
- **`run`**: Contains the core application logic for processing the input stream.
- **`util`**: Provides shared utilities, primarily for error handling.

## 3. Component Breakdown

### 3.1. `main.rs` - Application Entry Point

- **Responsibilities**: 
    - Collects command-line arguments from the operating system.
    - Initializes memory optimizations via `memx_cdy`.
    - Invokes the core library function `libaki_unbody::execute`.
    - Catches any errors returned from the library, prints them to standard error, and exits with a non-zero status code.

### 3.2. `lib.rs` - Core Library Facade

- **Responsibilities**:
    - Provides the main `execute` function, which serves as the primary entry point for the library's functionality.
    - Orchestrates the application flow by first calling the configuration parser and then the execution logic.
    - Handles the `--help` and `--version` requests directly, printing the relevant messages and exiting before the main run logic is ever called.

### 3.3. `conf` Module - Configuration

- **`CmdOptConf` struct**: A simple struct that holds the application's configuration after parsing (e.g., `opt_head: Option<usize>`, `flg_inverse: bool`).
- **`parse.rs`**: Uses the `flood-tide` crate to implement a GNU-style command-line parser. It defines all valid options, descriptions, and examples. It is responsible for all validation, such as ensuring that `--head` or `--tail` is present.
- **`cmd.help.rs.txt` / `cmd.match.rs.txt`**: These are auto-generated text files that are included directly by `parse.rs`. They contain the raw option definitions and the `match` statement for populating the `CmdOptConf` struct, effectively decoupling the repetitive parts of argument parsing from the main logic.

### 3.4. `run.rs` - Execution Logic

- **Responsibilities**: Contains the primary data processing logic.
- **`run()` function**: Acts as a dispatcher, checking the `flg_inverse` boolean in the `CmdOptConf` struct to decide which processing strategy to use.
- **`run_normal()`**: Implements the standard `head` and `tail` functionality. It reads from standard input line by line. Head lines are printed immediately. For the tail, it maintains a `Vec<String>` that acts as a circular buffer, ensuring only the last `N` lines are stored in memory.
- **`run_inverse()`**: Implements the `--inverse` logic. It reads lines from standard input, discarding the `head` lines, and buffering the rest. After the input is exhausted, it truncates the buffer to remove the `tail` lines before printing the remaining lines.

### 3.5. `util` Module - Utilities

- **`err.rs`**: Defines a `BrokenPipeError` trait. This allows the application to check for `std::io::ErrorKind::BrokenPipe` errors and exit gracefully. This is crucial for a CLI tool that is often part of a shell pipeline (e.g., `aki-unbody file.txt | head -n 5`), as it prevents panic messages when a downstream process closes the pipe early.
- **`opt_uc_x_param.rs`**: Defines the parsing and data structures for the special `-X` options.

## 4. Data Flow

1.  Execution starts in `main.rs`.
2.  Environment arguments are passed to `lib.rs:execute()`.
3.  `execute()` calls `conf::parse_cmdopts()` to parse the arguments into a `CmdOptConf` struct.
4.  If parsing fails or if `--help`/`--version` are present, `execute()` handles the response and exits.
5.  If parsing is successful, the `CmdOptConf` struct is passed to `run::run()`.
6.  `run::run()` selects a processing function (`run_normal` or `run_inverse`) based on the configuration.
7.  The selected function reads from standard input, applies the head/tail/inverse logic, and writes the result to standard output.
8.  Any I/O errors are propagated up via `anyhow::Result`.
9.  The `BrokenPipeError` utility in `run.rs` checks for broken pipe errors to allow for a clean exit.
10. Any other error is caught by `main.rs`, printed to standard error, and the application exits with status 1.

## 5. Mapping to Acceptance Criteria

- **AC-01, AC-02, AC-03 (Head/Tail)**: Implemented in `run.rs:run_normal()`.
- **AC-04 (Inverse)**: Implemented in `run.rs:run_inverse()`.
- **AC-05, AC-06 (Help/Version)**: Handled in `lib.rs:execute()` based on the result from `conf::parse_cmdopts()`.
- **AC-07, AC-08 (Arg Errors)**: Validated within `conf::parse_cmdopts()`.
- **AC-09 (Broken Pipe)**: Handled by the `is_broken_pipe()` check in `run.rs`, which relies on the `util::err::BrokenPipeError` trait.
